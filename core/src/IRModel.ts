/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the project root for license terms and full copyright notice.
*--------------------------------------------------------------------------------------------*/
import * as hash from "object-hash";
import { DataConnection, LogCategory } from "./pcf";
import { Loader } from "./loaders/Loader";
import { Logger } from "@itwin/core-bentley";

/**
 * A virtual store of IR entities and IR relationships generated by a {@link loaders/Loader!Loader}
 * and read by {@link PConnector!PConnector} to synchronize data into an iModel. {@link IRModel}
 * safe-guards the integrity of the external source data and normalize them if necessary.
 *
 * All the source data for PCF must first be mapped to a {@link IRModel}.
 *
 * IR stands for _intermediate representation_.
 */
export class IRModel {

  private _connection: DataConnection;
  private _lazyMode: boolean;
  private _loader: Loader;
  private _entityMap: { [entityKey: string]: IREntity };
  private _relMap: { [relationshipKey: string]: IRRelationship };

  constructor(loader: Loader, con: DataConnection) {
    this._lazyMode = con.lazyMode ?? false;
    this._loader = loader;
    this._connection = con;
    this._entityMap = {};
    this._relMap = {};
  }

  public get lazyMode() {
    return this._lazyMode;
  }

  public addEntity(entity: IREntity) {
    if (entity.key in this._entityMap) {
      Logger.logWarning(LogCategory.PCF, `IR Entity ${entity.key} already exists in IR Model.`);
      return;
    }
    this._entityMap[entity.key] = entity;
    if (entity.instances)
      entity.instances = IRModel.normalized(entity.instances);
  }

  public addRelationship(rel: IRRelationship) {
    if (rel.key in this._relMap) {
      Logger.logWarning(LogCategory.PCF, `IR Relationship Entity ${rel.key} already exists in IR Model.`);
      return;
    }
    this._relMap[rel.key] = rel;
    if (rel.instances)
      rel.instances = IRModel.normalized(rel.instances);
  }

  public deleteEntity(entity: IREntity) {
    if (!(entity.key in this._entityMap)) {
      Logger.logWarning(LogCategory.PCF, `IR Entity ${entity.key} does not exist in IR Model.`);
      return;
    }
    delete this._entityMap[entity.key];
  }

  public deleteRelationship(rel: IRRelationship) {
    if (!(rel.key in this._relMap)) {
      Logger.logWarning(LogCategory.PCF, `IR Relationship Entity ${rel.key} does not exist in IR Model.`);
      return;
    }
    delete this._relMap[rel.key];
  }

  public async getEntityInstances(irEntity: string): Promise<IRInstance[]> {
    if (!(irEntity in this._entityMap)) {
      Logger.logWarning(LogCategory.PCF, `Cannot find IR Entity ${irEntity}`);
      return [];
    }

    const entity = this._entityMap[irEntity];
    if (!entity.instances)
      entity.instances = await this._loader.getInstances(irEntity);

    return entity.instances;
  }

  public async getRelationshipInstances(irRelationship: string): Promise<IRInstance[]> {
    if (!(irRelationship in this._relMap)) {
      Logger.logWarning(LogCategory.PCF, `Cannot find IR Relationship Entity ${irRelationship}`);
      return [];
    }

    const rel = this._relMap[irRelationship];
    if (!rel.instances)
      rel.instances = await this._loader.getInstances(irRelationship);

    return rel.instances;
  }

  public static normalized(instances: IRInstance[]): IRInstance[] {
    const m: {[k: string]: IRInstance} = {};
    for (const instance of instances) {
      if (instance.key in m)
        continue;
      m[instance.key.toLowerCase()] = instance;
    }
    const newInstances = Object.values(m);
    return newInstances;
  }

  public async load() {
    await this._loader.open(this._connection);

    const entities = await this._loader.getEntities();
    const relationships = await this._loader.getRelationships();

    for (const entity of entities) {
      if (!this.lazyMode)
        entity.instances = await this._loader.getInstances(entity.key);
      this.addEntity(entity);
    }
    for (const relationship of relationships) {
      if (!this.lazyMode)
        relationship.instances = await this._loader.getInstances(relationship.key);
      this.addRelationship(relationship);
    }
  }

  public async clear() {
    this._entityMap = {};
    this._relMap = {};
    if (this._lazyMode)
      await this._loader.close();
  }
}

export interface IREntityProps {
  /**
   * Unique identifier of an {@link IREntity}. This identifier becomes the prefix of the code values
   * of the BIS elements it generates.
   */
  key: IREntityKey;

	/**
   * The {@link IRInstance} that belong to this {@link IREntity}.
   */
  instances?: IRInstance[];
}

/**
 * Represents a class of external object in your source data. An {@link IREntity} usually
 * corresponds to an `ECEntityClass`, for example, if you have an `ECEntityClass` with
 * `typeName="Wallpaper"` in your schema, you may have one IR entity corresponding to your EC
 * `Wallpaper` type responsible for all instances of that type.
 *
 * However, an IR entity can model a more granular division of objects in the real world. If you
 * have lavender wallpaper and mauve wallpaper, you may have two IR entities that each make
 * `Wallpaper` EC elements, but with different properties.
 */
export class IREntity {
  public key: string;
  public instances?: IRInstance[];

  constructor(props: IREntityProps) {
    this.key = props.key;
    this.instances = props.instances;
  }
}

export type IRRelationshipProps = IREntityProps;

/**
 * Represents a class of external relationships in your source data. Its members become BIS
 * link-table relationships in the iModel. A {@link IRRelationship} can correspond to an
 * `ECRelationshipClass`, but as with {@link IREntity} you may want more than one IR relationship to
 * map to the same `ECRelationshipClass`.
 */
export class IRRelationship extends IREntity {
  constructor(props: IRRelationshipProps) {
    super(props);
  }
}

export interface IRInstanceProps {
  /**
   * The _name of the attribute_ in your source data that holds the unique identifier of the
   * {@link IRInstance}. This is populated by {@link loaders/Loader!Loader#getPKey} and you don't need to
   * worry about it unless you want to specify that an {@link IREntity} has a different primary
   * key attribute than {@link loaders/Loader!LoaderProps#defaultPrimaryKey} using
   * {@link loaders/Loader!LoaderProps#primaryKeyMap}.
   *
   * For example, if I'm using {@link loaders/JSONLoader!JSONLoader}, and I give my instance a
   * primary key attribute `'guid'`, then I would define my IR instance in JSON like
   *
   * ```json
   * {
   *     "guid": "47880892-4418-4652-9e4c-fe7f6c615f85";
   *     ...
   * }
   * ```
   *
   * @todo This should probably be a member of {@link IREntity} and not {@link IRInstance} so it's
   * not needlessly duplicated across instances, because the loader already imposes
   * {@link IRInstance} have the same primary key attribute.
   */
  pkey: string;

  /**
   * The {@link IREntityProps#key} of the {@link IREntity} this instance belongs to.
   */
  entityKey: string;

  /**
   * Contains the value for keeping track of versions used in an external source.
   */
  version?: string;

  /**
   * Contains all the data associated with the {@link IRInstance}.
   */
  data?: {[attr: string]: any};
}

/**
 * See {@link IREntityProps#key}.
 */
export type IREntityKey = string;

/**
 * See {@link IRInstanceProps#pkey}. This is the type of the primary key value, not the primary
 * key attribute in the {@link IRInstance}.
 */
export type PrimaryKeyValue = string;

/**
 * A unique identifier of an {@link IRInstance}, formed by joining two unique identifiers in the
 * source data: {@link IREntity#key} and the value of the {@link IRInstance#pkey} attribute. This
 * type is interesting. It's a
 * [template literal type](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
 * that asserts that the unique identifier of an {@link IRInstance} can be any two `string`
 * seperated by a hyphen.
 */
export type IRInstanceKey = `${IREntityKey}-${PrimaryKeyValue}`;

/**
 * Represents an external object in your source data.
 *
 * An {@link IRInstance} corresponds to an instance of a BIS element, element aspect, relationship,
 * or navigation property. Alternatively, you can think of them mapping to an instance of an
 * `ECEntityClass` or `ECRelationshipClass`.
 */
export class IRInstance implements IRInstanceProps {

  public pkey: string;
  public entityKey: string;
  public data: {[attr: string]: any};
  public version: string;

  constructor(props: IRInstanceProps) {
    this.pkey = props.pkey;
    this.entityKey = props.entityKey;
    this.data = props.data ?? {};
    this.version = props.version ?? "";
    this.validate();
  }

  public static createKey(entityKey: string, pkv: string): IRInstanceKey {
    return `${entityKey}-${pkv}` as IRInstanceKey;
  }

  /**
   * See {@link IRInstance#codeValue}.
   */
  public get key(): IRInstanceKey {
    return this.codeValue;
  }

  /**
   * The primary key _value_ of the {@link IRInstance}, not to be confused with the
   * primary key attribute: {@link IRInstanceProps#pkey}. This function looks up the value at the
   * primary key attribute in the IR instance's {@link IRInstanceProps#data}.
   */
  public get pkv(): string {
    return this.get(this.pkey);
  }

  /**
   * The BIS code value of this instance. See {@link IRInstanceKey}.
   */
  public get codeValue(): IRInstanceKey {
    return `${this.entityKey}-${this.pkv}` as IRInstanceKey;
  }

  /**
   * The BIS user label of this instance.
   */
  public get userLabel(): string {
    const pkv = this.get(this.pkey);
    return pkv;
  }

  /**
   * A hash of this instance's data. If {@link IRInstanceProps#version} is not specified, this
   * is compared to the hash of the corresponding object in the iModel to determine if the object in
   * the source has changed. This is probably PCF's biggest advantage in my opinion: you don't have
   * to directly deal with external source aspects, because they're verbose.
   */
  public get checksum(): string {
    return hash.MD5(JSON.stringify(this.data));
  }

  /**
   * Fetch the value at the given attribute from this instance's bundle of source data.
   */
  public get(attr: string): any {
    if (!(attr in this.data))
      return undefined;
    return this.data[attr];
  }

  /**
   * Ensure that the primary key attribute exists in this instance's bundle of source data.
   *
   * @todo See {@link IRInstance#pkey}.
   */
  public validate(): void {
    if (!(this.pkey in this.data))
      throw new Error(`${this.pkey} does not exist on ${this.entityKey}`);
  }
}
