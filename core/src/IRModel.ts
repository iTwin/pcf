import * as hash from "object-hash";
import { ElementDMO, RelatedElementDMO, RelationshipDMO } from "./pcf";
import { Loader } from "./loaders/Loader";

/*
 * A virtual Entity-Relationship store generated by a Loader and read by PConnector to synchronize data into an iModel.
 * IR Model safe-guards the integrity of the external source data and normalize them if necessary.
 *
 * All the source data for PCF must first be mapped to an IR Model.
 *
 * IR = Intermediate Representation
 */
export class IRModel {

  public entityMap: {[key: string]: IREntity};
  public relMap: {[key: string]: IRRelationship};

  constructor(entities: IREntity[], relationships: IRRelationship[]) {
    this.entityMap = {};
    for (const e of entities) {
      this.entityMap[e.key] = IRModel.normalized(e);
    }
    this.relMap = {};
    for (const r of relationships) {
      this.relMap[r.key] = r;
    }
  }

  public getEntityInstances(dmo: ElementDMO): IRInstance[] {
    if (!(dmo.irEntity in this.entityMap))
      return [];
    let instances = this.entityMap[dmo.irEntity].instances;
    if (typeof dmo.doSyncInstance === "function")
      instances = instances.filter(dmo.doSyncInstance);
    return instances;
  }

  public getRelInstances(dmo: RelationshipDMO | RelatedElementDMO): IRInstance[] {
    if (!(dmo.irEntity in this.relMap))
      return [];
    let instances = this.relMap[dmo.irEntity].instances;
    if (typeof dmo.doSyncInstance === "function")
      instances = instances.filter(dmo.doSyncInstance);
    return instances;
  }

  public static normalized(entity: IREntity): IREntity {
    const m: {[k: string]: IRInstance} = {};
    for (const instance of entity.instances) {
      if (instance.key in m)
        continue;
      m[instance.key.toLowerCase()] = instance;
    }
    const newInstances = Object.values(m);
    entity.instances = newInstances;
    return entity;
  }

  public static async fromLoader(loader: Loader) {
    const entities = await loader.getEntities();
    let relationships: IRRelationship[] = [];
    if (typeof loader.getRelationships === "function")
      relationships = await loader.getRelationships();
    await loader.close();
    return new IRModel(entities, relationships);
  }

  public static compare(modelA: IRModel, modelB: IRModel): boolean {
    const entityMapA = modelA.entityMap;
    const entityMapB = modelB.entityMap;
    if (JSON.stringify(entityMapA) !== JSON.stringify(entityMapB))
      return false;

    const relMapA = modelA.relMap;
    const relMapB = modelB.relMap;
    if (JSON.stringify(relMapA) !== JSON.stringify(relMapB))
      return false;
    
    return true;
  }
}

export interface IREntityProps {

  /*
   * Unique identifier of an IR Entity
   */
  key: string;

  /*
   * All the IR Instances that belong to this IR Enitty
   */
  instances?: IRInstance[];
}

/*
 * Represents an external object class
 * 
 * An IR Entity corresponds to an EC Entity 
 */
export class IREntity {

  public key: string;
  public instances: IRInstance[];

  constructor(props: IREntityProps) {
    this.key = props.key;
    this.instances = props.instances ?? [];
  }
}

export interface IRRelationshipProps extends IREntityProps {}

/*
 * Represents an external object class that describes relationships. (e.g. link tables)
 *
 * An IR Relationship corresponds to an EC Relationship
 */
export class IRRelationship extends IREntity {
  constructor(props: IRRelationshipProps) {
    super(props);
  }
}

export interface IRInstanceProps {

  /*
   * Primary Key
   */
  pkey: string;

  /*
   * References an IR Entity
   */
  entityKey: string;

  /*
   * Contains the value for keeping track of versions used in an external source
   */
  version?: string;

  /*
   * Contains all the data associated with current IR Instance
   */
  data?: {[attr: string]: any};
}

/*
 * Unique identifier of an IR Entity
 */
type IREntityKey = string;

/*
 * The primary-key-value (ID) of an IR Instance
 */
type PrimaryKeyValue = string;

/*
 * A unique identifier of an IR Instance
 */
export type IRInstanceKey = `${IREntityKey}-${PrimaryKeyValue}`;

/*
 * Represents an external object / instance of an external object class.
 * 
 * An IR Instance corresponds to an EC Instance
 */
export class IRInstance implements IRInstanceProps {

  public pkey: string;
  public entityKey: string;
  public data: {[attr: string]: any};
  public version: string;

  constructor(props: IRInstanceProps) {
    this.pkey = props.pkey;
    this.entityKey = props.entityKey;
    this.data = props.data ?? {};
    this.version = props.version ?? "";
    this.validate();
  }

  public static createKey(entityKey: string, pkv: string): IRInstanceKey {
    return `${entityKey}-${pkv}` as IRInstanceKey;
  }

  /*
   * Unique Identifier of an IRInstance
   */
  public get key(): IRInstanceKey {
    return this.codeValue;
  }

  /*
   * Primary Key Value (pkv)
   */
  public get pkv(): string {
    return this.get(this.pkey);
  }

  /*
   * Corresponding BIS Code Value
   */
  public get codeValue(): IRInstanceKey {
    return `${this.entityKey}-${this.pkv}` as IRInstanceKey;
  }

  /*
   * Corresponding BIS User Label
   */
  public get userLabel(): string {
    const pkv = this.get(this.pkey);
    return pkv;
  }

  public get checksum(): string {
    return hash.MD5(JSON.stringify(this.data));
  }

  public get(attr: string): any {
    if (!(attr in this.data))
      return undefined;
    return this.data[attr];
  }

  public validate(): void {
    if (!(this.pkey in this.data))
      throw new Error(`${this.pkey} does not exist on ${this.entityKey}`);
  }
}
