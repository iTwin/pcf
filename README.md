[![Build Status](https://dev.azure.com/bentleycs/iModelTechnologies/_apis/build/status/iTwin.pcf?branchName=main)](https://dev.azure.com/bentleycs/iModelTechnologies/_build/latest?definitionId=5431&branchName=main)

Table of Contents
=======================

* [What is iTwin pcf?](#what-is-itwin-pcf)
* [Constructs](#constructs)
* [Getting started](#getting-started)
* [Cautions](#cautions)
* [Concepts](#concepts)
  * [Declarative Synchronization](#declarative-synchronization)
  * [Minimized Runtime Error and Testing](#minimized-runtime-error-and-testing)
  * [Single Source of Truth](#single-source-of-truth)
  * [Empowering Lossless Synchronization](#empowering-lossless-synchronization)
  * [Intermediate Representation](#intermediate-representation)
  * [What is the difference between a Connector and a Loader?](#what-is-the-difference-between-a-connector-and-a-loader)
  * [How to write a Loader?](#how-to-write-a-loader)
* [Install from source](#install-from-source)
* [Road Map](#road-map)

# What is iTwin pcf?

pcf (Parametric Connector Framework) is a tool for synchronizing external data with your digital twin, iModel, deterministically and efficiently. As opposed to traditional [iTwin Connectors](https://www.itwinjs.org/learning/imodel-connectors/), pcf allows you to **define** your iModel as code then it takes care of the steps to synchronize it to your desired state. With pcf, you have the full control over how you would like your data to end up in an iModel with minimal programming effort.


# Constructs

| Name             | Definition                                                                                                   |
|------------------|--------------------------------------------------------------------------------------------------------------|
|**IR Model**      | An intermediate representation virtual Entity-Relationship store generated by a **Loader** from your source data. |
|**Loader**        | An accessor to a data format, converting the source data format to an IR Model (intermediate representation model). You may use an existing Loader or write your own. |
|**DMO**           | A DMO (Dynamic Mapping Object) defines the mappings between IR Model and EC schema. |
|**Node**          | A Node represents a unit of synchronization and some Nodes use DMO to populate multiple EC Instances. An iModel is synchronized based on user-defined Nodes and linkages between them. |


# Getting started

```console

# 1. install global pcf command line utility
npm install -g @itwin/pcf-cli

# 2. initialize a connector template with a name
pcf init <name of your connector>

# 3. add app specific info in YourConnector/App.ts

# 4. execute your connector (compilation is included in this command)
npm run start

```

Currently, all the documentations and API references of this project are embedded in source files. Use your IDE/language server to look them up through go-to-definitions.

# Cautions

* Dependencies
    * You should not install any iTwin.js related dependencies aside from schema npm packages (@bentley/<schema name>-schema). If the same package is installed in two different versions by your connector and pcf, you may encounter hidden bugs.
    * Most existing domain schema packages can be found [here](https://www.npmjs.com/search?q=%40bentley%20schema%20).
* Nodes
    * The following entity class cannot be deleted from your iModel once created: Subject, Partition, Model.
    * Modifying the key of SubjectNode or ModelNode would cause new Subject, Model, and Partition to be created.
    * Parent-child Modeling is not supported yet. Only the top models and their elements are synchronized.
* Dynamic Schema
    * Only Primitive EC Properties can be added to DMO.ecElement/ecRelationship. They cannot be deleted once added.
* Loaders
    * Loader is recorded as a Repository Link element in your iModel.
    * Currently supported loaders can be found in pcf/core/src/loaders directory.
* "Too Many Requests"
    * If you saw this message - "Requests are sent too frequent. Sleep for 60 seconds", it means your registered Client ID should probably be upgraded due to rate limiting, otherwise your job will be slowed down with a slight chance of failing.

# Concepts

Read this only if you want to gain a deeper understanding of what makes pcf great and unique.

## Declarative Synchronization

pcf allows you to represent your external source data in an iModel using two constructs: **DMO's** and **Nodes** (see definitions below). It makes sure that every EC Entity corresponding to your source data are correctly inserted, updated, and deleted in your iModel. With pcf, you also gain the power to organize [the hierarchy](https://www.itwinjs.org/bis/intro/information-hierarchy/) of your digital twin (iModel) so your end iTwin.js applications knows what to expect from your iModels.

## Minimized Runtime Error and Testing

pcf minimizes runtime errors in its connectors by maximizing the functionalities offered by TypeScript so that most errors can be caught at compile time and runtime before a connector job kicks off. As previously mentioned, pcf follows the declarative paradigm so a connector does not contain any custom logics rather it contains only object definitions, which can be linted strictly.

Given that object definitions (**DMOs** and **Nodes**) are the main inputs to your connector, so long as their definitions are correct, each synchronization job is guaranteed to succeed with pcf.

Functionalities such as code-completion and code-refactoring available in most modern IDE's (e.g Visual Studio Code) will help you to write the correct definitions for them. Since most runtime errors are avoided at compile time and the source code of a connector only contains a set of object definitions, unit/integration tests are no longer needed for connectors, making them much easier to maintain. (except for geometry transformations)

## Single Source of Truth

SSOT = Single Source of Truth

As both of your connector and source data evolve, it is often that two types of changes will need to be made: 
1. mapping changes between the source schema and EC schema. 
2. iModel hierarchy changes of the EC Entities created from the source data. 

As we are constantly dealing with changes, it is important to have an easy way to precisely capture these changes and inform downstream iTwin.js applications about them. pcf solves this problem by making **DMO** the SSOT of the mappings between source schema and EC schema and making **Node** the SSOT of the hierarchy of mapped EC Entities within the source discipline. 

Sometimes you may want to define and update your own schema (called "dynamic schema" in EC terms) to better represent your source schema in the EC world. With pcf, you no longer need to hand-write a xml EC Schema, it is auto-generated and imported into your iModel if you have defined your own EC classes in **DMO's**. Traditional iTwin Connectors keep schema in a separate xml file and embed mapping details across source files.

## Empowering Lossless Synchronization

The term “lossless” here means all the structures and properties of the source data are maintained, not purely bytes. Missing a few pieces of information is ok because we can always add them later, but missing constraints could corrupt things. 

When one converts a data format to another, it is likely that not all the properties of the source data are maintained in the target format (considered as a lossy transformation in pcf). For example, referential integrity gets lost if a synchronization job missed a database relationship. This could cause a disastrous consequence by allowing the target data to be modified without the relationship constraint.  

This mistake cannot be avoided at the framework level, the person who's responsible for the mappings between the source and target format must always be extreme cautious in defining mappings. However, the way mappings are presented through DMO in pcf significantly makes the job of this person easier and allows someone without much programming expertise to inspect the mappings. 


## Intermediate Representation

An IR Model is an intermediate representation of your source data. It is a simple virtual Entity-Relationship store generated by a **Loader**. A **Loader** is a simple class that handles the conversion from a source data format to IR Model. In pcf, **Loader** is the only construct that interacts with the outside world. There could be a **Loader** for any data format, currently supported ones are JSON Loader, XLSX (Excel) Loader, and SQLite Loader. So long as a data format has a Loader, it can be imported into an iModel through pcf. 

We must not always assume that the source data are normalized or well-modeled. Having an IR Model safeguards against dirty source data, thus maintaining the data quality in your iModel. IR Model forces every external class to have a primary key and value so that one can always use information stored in the external source to query an iModel and be confident that only a single EC instance gets returned. This is just one kind of optimization. Other kinds of optimizations could also be implemented on IR Model such as dynamically inferring relationships in your data if they're not provided. 
 
Why not use an existing file format like SQLite as the Intermediate Representation as opposed to creating our own virtual data store (IR Model)? This is possible, however, the simplicity and flexibility provided by a virtual data store cannot be beaten by any existing file format, specifically there are two compelling reasons:
1. it makes the job of a Loader significantly easier, as it does not require additional logic & library to write to the IR format (IR format = SQLite in this example). In another word, instead of having a simple ORM to the IR format (TS Object ==write==> SQLite ==read==> TS Object), we use TS Object straight up, removing the two steps of interacting with the IR SQLite database. When file size gets un-managably large to stay in memory, we could allow IR Model to be either lazily loaded or persist its data to disk in a SQLite file and load them as needed, thus hiding the ORM implementation.
2. since IR Model is **virtual** (being a TS Object in memory), it can be extended easily. With IR Model, pcf is able to provide a set of default Element Properties based on the structure of IR Model. For example, the primary key value of an IR Instance is used as the UserLabel value of an EC Instance and part of its CodeValue. Moreover, subroutines can be implemented to check the integrity of external data as well as performing necessary normalization. 
 
## What is the difference between a Connector and a Loader?

One reason that a highly configurable connector is needed is that it's not possible to have a single connector for a single data format. Data formats could have different schemas that cannot be understood by a single connector. For example, the databases of different users have completely different schemas and importing those data into iModels will always require configurations. 

```

Without pcf: data source A == Connector for A => iModel

With    pcf: data source A == Loader    for A => IR Model == PConnector => iModel 

```

This new architecture separates the concern of accessing an external data from the connector so that we can reuse a connector to populate iModels. It's much easier to write a Loader than to write a full-blown Connector as you don't have to deal with the intricacies in the iTwin.js world. It requires zero expertise in iTwin.js to write a Loader. As long as there's a **Loader** for a data format, its data can be imported into an iModel through pcf.


## How to write a Loader?

You can write your own Loader by implementing [Loader](https://github.com/itwin/pcf/blob/main/core/src/loaders/Loader.ts) or extending one of the currently supported Loaders.

# Install from source 

### pre-steps:
```console
# clone pcf repo
git clone https://github.com/iTwin/pcf.git

# install pcf core dependencies
cd core
npm ci 

# build
npm run build
```

### Option 1: try pcf locally with your connector:
```console
# create global symlink
npm link

# use @itwin/pcf package locally without installing it
cd <your connector project dir>
npm link @itwin/pcf
```

### Option 2: run pcf unit tests:
```console
npm run test
```

# Road Map

- [ ] handles multiple source files in a single job?
- [ ] update elements in parallel (persist IR model on disk)
- [ ] add a full suite of command line offerings
- [ ] add domain schema service and sync them
- [ ] add wrappers for other programming languages
- [ ] data lineage, add a wrapper around Element classes that records the transformations, maybe useful for iModel exporter
- [ ] dynamically infer the relationship between external entities
- [ ] read large JSON (https://github.com/uhop/stream-json)

# Inspired by

- [Compiler Design](https://en.wikipedia.org/wiki/Compiler)
- [Object-Relational Mapping](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)
- [AWS CDK](https://github.com/aws/aws-cdk)
- [Terraform](https://github.com/hashicorp/terraform)
